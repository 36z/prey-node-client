/////////////////////////////////////////
// node-gst-launch
// wrapper around gst-launch for NodeJS
// Written by Tom√°s Pollak
// (c) 2011 Fork Ltd.
// Licensed under the GPLv3
/////////////////////////////////////////

var fs = require('fs'),
		spawn = require('child_process').spawn;

var debug = true;

function mixin(target, source) {
	Object.keys(source).forEach(function(key) {
		target[key] = source[key];
	});
	return target;
}

var GStreamer = {

	launcher: 'gst-launch-0.10',
	// launcher: 'C:\\test\\gstreamer\\gst-launch.exe',
	streamTimeout: 1000,

	videoSources: {
		linux: 'v4l2src',
		darwin: 'osxvideosrc',
		win32: 'dshowvideosrc'
	},

	getVideoSource: function(){
		return this.videoSources[process.platform];
	},

	parseDestination: function(dest){

		// url:port regex
		var matches = dest.match(/([a-z0-9\.]+):([0-9]+)/);
		if(matches){
			return ['tcpclientsink', 'host=' + matches[1], 'port=' + matches[2]];
		} else {
			var matches = dest.match(/(.+)\.([a-z0-9]{2,4})/);
			if(matches) {
				return ['filesink', 'location=' + dest];
			}
		}

	},

	spawnChild: function(args){

		if(debug) console.log(args.join(' '));

		var child = spawn(this.launcher, args);

		child.stdout.on('data', function(d){
			if(debug) console.log(d.toString());
		});

		child.stderr.on('data', function(d){
			if(debug) console.log(d.toString());
		});

		return child;

	},

	launchCommand: function(args, callback, object){

		var child = this.spawnChild(args);

		child.on('exit', function(code){
			// console.log(code)
			if(code == 0) { // all good
				if(callback) callback(object);
			} else {
				// if(object) fs.unlink(object);
				if(callback) callback(false);
			}
		});

		return child;

	},

	launchStream: function(args, callback){

		var child = this.spawnChild(args);

		setTimeout(function(){
			try {
				process.kill(child.pid, 0); // running
				if(callback) callback(true);
			} catch(e) {
				if(callback) callback(false);
			}
		}, this.streamTimeout);

		return child;

	},

	playSound: function(file, options, callback){

		var cb = (typeof options == 'function') ? options : callback ? callback : false;
		var dest = options.dest || 'autoaudiosink';

		var args = [
			'filesrc', 'location=' + file,
			'!', 'decodebin',
			'!', 'audioconvert',
			'!', 'audioresample',
			'!', dest
		];

		return this.launchCommand(args, cb, file);

	},

	captureFrame: function(file, options, callback){

		var cb = (typeof options == 'function') ? options : callback ? callback : false;
		var src  = options.src  || this.getVideoSource(); // autovideosrc
		var enc  = file.search(/\.jpe?g$/) == -1 ? 'pngenc' : 'jpegenc';
		var framerate = options.framerate || '15/1';

		if(options.width && options.height)
			var format = ',width=' + options.width + ',height=' + options.height;
		else
			var format = ',width=640,height=480';

		format = ''; // so that it works

		var args = [
			src, 'num-buffers=1',
			'!', 'ffmpegcolorspace',
			'!', 'video/x-raw-yuv' + format + ',framerate=' + framerate,
			'!', enc,
			'!', 'filesink', 'location=' + file
		];

		return this.launchCommand(args, cb, file);

	},

	streamAudio: function(options, callback){

		var src  = options.src  || 'autoaudiosrc';
		var dest = options.desc || 'autoaudiosink';

		var args = [
			src,
			'!', 'audioconvert',
			'!', 'audioresample',
			'!', dest
		];

		return this.launchStream(args, callback);

	},

	streamVideo: function(options, callback){

		var src  = options.src  || this.getVideoSource(); // 'autovideosrc';
		var dest = options.dest ? this.parseDestination(options.dest) : 'autovideosink';

		var enc  = options.encoder || 'vp8enc';
		var framerate = options.framerate || '15/1';

		if(options.width && options.height)
			var format = ',width=' + options.width + ',height=' + options.height;
		else
			var format = ',width=640,height=480';

		format = ''; // so that it works

		var muxer_args = ['m.', 'webmmux', 'name=m', 'streamable=true', '!'];

		var args = [
			src,
			'!', 'video/x-raw-rgb' + format + ',framerate=' + framerate,
			'!', 'ffmpegcolorspace',
			'!', enc, 'speed=2',
//		'max-latency=2', 'max-keyframe-distance=30',
			'!'
		];

		if(options.audio) {
			args = args.concat(['queue2',
			'!', 'm.', 'autoaudiosrc',
			'!', 'audioconvert',
			'!', 'vorbisenc',
			'!', 'queue2',
			'!']);
		}

		args = args.concat(muxer_args).concat(dest);
//		console.log(args.join(' '));

		return this.launchStream(args, callback);

	},

	streamAudioVideo: function(options, callback){

		return this.streamVideo(mixin(options, {audio: true}), callback);

	}

};

module.exports = GStreamer;
